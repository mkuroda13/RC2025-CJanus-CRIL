// Code generated by goyacc -o parser.go -p parser parser.y. DO NOT EDIT.

//line parser.y:2
package main

import __yyfmt__ "fmt"

//line parser.y:2

import (
	"bufio"
	"flag"
	"fmt"
	"os"
	"regexp"
	"slices"
	"strconv"
	"strings"
)

var cmp *compiler
var prep = true

//line parser.y:18
type parserSymType struct {
	yys    int
	num    int
	ident  string
	varid  string
	varids []string
	ary    aryentry
}

const NUM = 57346
const IDENT = 57347
const PLUS = 57348
const MINUS = 57349
const XOR = 57350
const MULT = 57351
const DIV = 57352
const MOD = 57353
const AND = 57354
const OR = 57355
const BITAND = 57356
const BITOR = 57357
const LEQ = 57358
const GEQ = 57359
const NEQ = 57360
const EQ = 57361
const LES = 57362
const GRT = 57363
const LSB = 57364
const RSB = 57365
const LCB = 57366
const RCB = 57367
const COMMA = 57368
const LPR = 57369
const RPR = 57370
const PROCEDURE = 57371
const MAIN = 57372
const INT = 57373
const IF = 57374
const THEN = 57375
const ELSE = 57376
const FI = 57377
const FROM = 57378
const DO = 57379
const LOOP = 57380
const UNTIL = 57381
const LOCAL = 57382
const DELOCAL = 57383
const CALL = 57384
const UNCALL = 57385
const PAR = 57386
const RAP = 57387
const SKIP = 57388
const BEGIN = 57389
const END = 57390
const P = 57391
const V = 57392
const SYNC = 57393
const WAIT = 57394
const ACQUIRE = 57395

var parserToknames = [...]string{
	"$end",
	"error",
	"$unk",
	"NUM",
	"IDENT",
	"PLUS",
	"MINUS",
	"XOR",
	"MULT",
	"DIV",
	"MOD",
	"AND",
	"OR",
	"BITAND",
	"BITOR",
	"LEQ",
	"GEQ",
	"NEQ",
	"EQ",
	"LES",
	"GRT",
	"LSB",
	"RSB",
	"LCB",
	"RCB",
	"COMMA",
	"LPR",
	"RPR",
	"PROCEDURE",
	"MAIN",
	"INT",
	"IF",
	"THEN",
	"ELSE",
	"FI",
	"FROM",
	"DO",
	"LOOP",
	"UNTIL",
	"LOCAL",
	"DELOCAL",
	"CALL",
	"UNCALL",
	"PAR",
	"RAP",
	"SKIP",
	"BEGIN",
	"END",
	"P",
	"V",
	"SYNC",
	"WAIT",
	"ACQUIRE",
}

var parserStatenames = [...]string{}

const parserEofCode = 1
const parserErrCode = 2
const parserInitialStackSize = 16

//line parser.y:687

type aryentry struct {
	val string
	lab string
}

//yylval of type parserSymType provides
//yylval.<tokenname>

// Extremely dirty lexer
type token struct {
	reg     *regexp.Regexp
	process func(match string, yylval *parserSymType) int
}

type compiler struct {
	stackdepth    []int
	tmpindex      int
	labelindex    int
	output        map[string]string
	currentproc   []string
	callingproc   string
	procid        map[string]int      //fib -> 1 (its block id)
	procargs      map[string][]string // fib.0.0 -> [n,r]
	procargtype   map[string][]string
	argindex      int
	recindex      int
	tokenrec      string
	dorectoken    bool
	prevtoken     string
	currentrecord string
	earlyexec     map[string]string
	lateexec      map[string]string
	memrec        map[string]int
	glovartype    map[string]string
	memmax        int
}

func newCompiler() *compiler {
	s := make([]int, 1, 1)
	s[0] = -1
	return &compiler{s, 0, 0, make(map[string]string), make([]string, 0), "", make(map[string]int), make(map[string][]string), make(map[string][]string), 0, 0, "", false, "", "", make(map[string]string), make(map[string]string), make(map[string]int), make(map[string]string), 0}
}

func (c *compiler) getLabel() string {
	t := c.labelindex
	c.labelindex++
	return "l" + strconv.Itoa(t)
}

func (c *compiler) getTmp() string {
	t := c.tmpindex
	c.tmpindex++
	return "$tmp" + strconv.Itoa(t)
}
func (c *compiler) getBlockId() string {
	name := ""
	for i := range len(c.stackdepth) - 1 {
		if i != 0 {
			name += "."
		}
		name += strconv.Itoa(c.stackdepth[i])
	}
	return name
}
func (c *compiler) getIdMod() string {
	name := ""
	for i := range len(c.stackdepth) - 1 {
		name += "."
		name += strconv.Itoa(c.stackdepth[i])
	}
	return name
}
func (c *compiler) getRec() string {
	t := c.recindex
	c.recindex++
	return "rec" + strconv.Itoa(t)
}
func (c *compiler) indent() {
	//increment last(used to be shadow) & append new shadow as -1
	c.stackdepth[len(c.stackdepth)-1]++
	c.stackdepth = append(c.stackdepth, -1)
}
func (c *compiler) unindent() {
	//delete one shadow (thus making it one shorter)
	c.stackdepth = c.stackdepth[:len(c.stackdepth)-1]
}
func (c *compiler) exec(s string) {
	if c.currentrecord != "" {
		c.earlyexec[c.currentrecord] += s
		c.earlyexec[c.currentrecord] += "\n"
	} else if !c.dorectoken {
		c.output[c.currentproc[len(c.currentproc)-1]] += s
		c.output[c.currentproc[len(c.currentproc)-1]] += "\n"
	}
}

// same as exec but recorded on lateexec rather than earlyexec
func (c *compiler) unexec(s string) {
	if c.currentrecord != "" {
		c.lateexec[c.currentrecord] += s
		c.lateexec[c.currentrecord] += "\n"
	} else if !c.dorectoken {
		c.output[c.currentproc[len(c.currentproc)-1]] += s
		c.output[c.currentproc[len(c.currentproc)-1]] += "\n"
	}
}

func (c *compiler) addProc(name string) {
	s := name + c.getIdMod()
	c.procid[s] = c.stackdepth[len(c.stackdepth)-1] + 1 //nextmod
	c.procargs[s] = make([]string, 0)
	c.procargtype[s] = make([]string, 0)
	c.output[s] = ""
	c.beginProc(name)
}
func (c *compiler) addProcArg(arg string, t string) {
	c.procargs[c.currentproc[len(c.currentproc)-1]] = append(c.procargs[c.currentproc[len(c.currentproc)-1]], arg)
	c.procargtype[c.currentproc[len(c.currentproc)-1]] = append(c.procargtype[c.currentproc[len(c.currentproc)-1]], t)
}
func (c *compiler) beginProc(name string) {
	c.currentproc = append(c.currentproc, name+c.getIdMod())
}
func (c *compiler) endProc() {
	c.currentproc = c.currentproc[:len(c.currentproc)-1]
}
func (c *compiler) setCallingProc(name string) {
	c.callingproc = name
}
func (c *compiler) getProcArg() (string, string) {
	s := c.procargs[c.callingproc][c.argindex]
	t := c.procargtype[c.callingproc][c.argindex]
	c.argindex++
	return s, t
}

func (c *compiler) getCallingProcId() string {
	return strconv.Itoa(c.procid[c.callingproc])
}
func (c *compiler) resetArgIndex() {
	c.argindex = 0
}
func (c *compiler) getNextMod() string {
	return strconv.Itoa(c.stackdepth[len(c.stackdepth)-1] + 1)
}
func (c *compiler) getPrevNextMod() string {
	return strconv.Itoa(c.stackdepth[len(c.stackdepth)-1])
}
func (c *compiler) getCurrentMod() string {
	return strconv.Itoa(c.stackdepth[len(c.stackdepth)-2])
}
func (c *compiler) getCurrentProc() string {
	return c.currentproc[len(c.currentproc)-1]
}
func (c *compiler) getParCount() int {
	return c.stackdepth[len(c.stackdepth)-1]
}
func (c *compiler) beginRecord(key string) {
	c.earlyexec[key] = ""
	c.lateexec[key] = ""
	c.currentrecord = key
}

func (c *compiler) execEarlyRecord(key string) {
	outd := c.currentproc[len(c.currentproc)-1]
	c.output[outd] += "{{" + key + ",early}}"
}

func (c *compiler) execLateRecord(key string) {
	outd := c.currentproc[len(c.currentproc)-1]
	c.output[outd] += "{{" + key + ",late}}"
}

func (c *compiler) endRecord(key string) {
	c.currentrecord = ""
}
func (c *compiler) recordToken() {
	c.dorectoken = true
	c.tokenrec = ""
	c.prevtoken = ""
}
func (c *compiler) getRecordedToken() string {
	c.dorectoken = false
	return c.tokenrec
}
func (c *compiler) newmem(name string, size int, t string) {
	c.memrec[name] = c.memmax
	c.glovartype[name] = t
	c.memmax += size
}
func (c *compiler) reset() {
	c.currentproc = make([]string, 0)
	c.callingproc = ""
	c.stackdepth = make([]int, 1, 1)
	c.stackdepth[0] = -1
}
func (c *compiler) export() string {
	s := ""
	for _, v := range c.output {
		for k, v1 := range c.earlyexec {
			v = strings.ReplaceAll(v, "{{"+k+",early}}", v1)
		}
		for k, v1 := range c.lateexec {
			sl := strings.Split(v1, "\n")
			ns := ""
			slices.Reverse(sl)
			for _, v2 := range sl {
				if v2 != "" {
					ns += v2
					ns += "\n"
				}
			}
			v = strings.ReplaceAll(v, "{{"+k+",late}}", ns)
		}
		s += v
		s += "\n"
	}
	return s
}

type progLex struct {
	input  string
	tokens []token
}

func newLexer(filename string) *progLex {
	file, _ := os.ReadFile(filename)
	tokens := make([]token, 0, 30)
	//add token stuff
	//special chars
	tokens = append(tokens, token{regexp.MustCompile(`^\+`),
		func(match string, yylval *parserSymType) int {
			return PLUS
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^-`),
		func(match string, yylval *parserSymType) int {
			return MINUS
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^\^`),
		func(match string, yylval *parserSymType) int {
			return XOR
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^\*`),
		func(match string, yylval *parserSymType) int {
			return MULT
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^/`),
		func(match string, yylval *parserSymType) int {
			return DIV
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^%`),
		func(match string, yylval *parserSymType) int {
			return MOD
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^&&`),
		func(match string, yylval *parserSymType) int {
			return AND
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^||`),
		func(match string, yylval *parserSymType) int {
			return OR
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^&`),
		func(match string, yylval *parserSymType) int {
			return BITAND
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^|`),
		func(match string, yylval *parserSymType) int {
			return BITOR
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^<=`),
		func(match string, yylval *parserSymType) int {
			return LEQ
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^>=`),
		func(match string, yylval *parserSymType) int {
			return GEQ
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^!=`),
		func(match string, yylval *parserSymType) int {
			return NEQ
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^=`),
		func(match string, yylval *parserSymType) int {
			return EQ
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^<`),
		func(match string, yylval *parserSymType) int {
			return LES
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^>`),
		func(match string, yylval *parserSymType) int {
			return GRT
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^\(`),
		func(match string, yylval *parserSymType) int {
			return LPR
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^\)`),
		func(match string, yylval *parserSymType) int {
			return RPR
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^\[`),
		func(match string, yylval *parserSymType) int {
			return LSB
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^\]`),
		func(match string, yylval *parserSymType) int {
			return RSB
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^{`),
		func(match string, yylval *parserSymType) int {
			return LCB
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^}`),
		func(match string, yylval *parserSymType) int {
			return RCB
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^,`),
		func(match string, yylval *parserSymType) int {
			return COMMA
		}})
	//keywords
	//word boundary come in handy
	tokens = append(tokens, token{regexp.MustCompile(`^V\b`),
		func(match string, yylval *parserSymType) int {
			return V
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^P\b`),
		func(match string, yylval *parserSymType) int {
			return P
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^procedure\b`),
		func(match string, yylval *parserSymType) int {
			return PROCEDURE
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^main\b`),
		func(match string, yylval *parserSymType) int {
			return MAIN
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^int\b`),
		func(match string, yylval *parserSymType) int {
			return INT
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^if\b`),
		func(match string, yylval *parserSymType) int {
			return IF
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^then\b`),
		func(match string, yylval *parserSymType) int {
			return THEN
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^else\b`),
		func(match string, yylval *parserSymType) int {
			return ELSE
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^fi\b`),
		func(match string, yylval *parserSymType) int {
			return FI
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^from\b`),
		func(match string, yylval *parserSymType) int {
			return FROM
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^do\b`),
		func(match string, yylval *parserSymType) int {
			return DO
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^loop\b`),
		func(match string, yylval *parserSymType) int {
			return LOOP
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^until\b`),
		func(match string, yylval *parserSymType) int {
			return UNTIL
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^local\b`),
		func(match string, yylval *parserSymType) int {
			return LOCAL
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^delocal\b`),
		func(match string, yylval *parserSymType) int {
			return DELOCAL
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^call\b`),
		func(match string, yylval *parserSymType) int {
			return CALL
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^uncall\b`),
		func(match string, yylval *parserSymType) int {
			return UNCALL
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^par\b`),
		func(match string, yylval *parserSymType) int {
			return PAR
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^rap\b`),
		func(match string, yylval *parserSymType) int {
			return RAP
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^begin\b`),
		func(match string, yylval *parserSymType) int {
			return BEGIN
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^end\b`),
		func(match string, yylval *parserSymType) int {
			return END
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^skip\b`),
		func(match string, yylval *parserSymType) int {
			return SKIP
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^sync\b`),
		func(match string, yylval *parserSymType) int {
			return SYNC
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^wait\b`),
		func(match string, yylval *parserSymType) int {
			return WAIT
		}})
	tokens = append(tokens, token{regexp.MustCompile(`^acquire\b`),
		func(match string, yylval *parserSymType) int {
			return ACQUIRE
		}})
	//integer constants
	tokens = append(tokens, token{regexp.MustCompile(`^-?\d+`),
		func(match string, yylval *parserSymType) int {
			n, _ := strconv.Atoi(match)
			yylval.num = n
			return NUM
		}})
	//identifier (variable / func / whatever)
	tokens = append(tokens, token{regexp.MustCompile(`^\w+`),
		func(match string, yylval *parserSymType) int {
			yylval.ident = match
			return IDENT
		}})
	return &progLex{string(file), tokens}
}

func (x *progLex) Lex(yylval *parserSymType) int {
	x.input = strings.TrimLeft(x.input, "\r\n\t\f\v ") //remove whitespaces
	if len(x.input) == 0 {
		return 0
	}
	for _, v := range x.tokens {
		s := v.reg.FindString(x.input)
		if s != "" {
			x.input = strings.TrimPrefix(x.input, s)
			if cmp.dorectoken {
				cmp.tokenrec += cmp.prevtoken
				cmp.prevtoken = s
			}
			return v.process(s, yylval)
		}
	}
	panic("Token not found")
}

func (x *progLex) Error(s string) {
	panic(s)
}

func main() {
	flag.Usage = func() {
		fmt.Fprintf(flag.CommandLine.Output(), "usage: %s [args] file\n", os.Args[0])
		flag.PrintDefaults()
	}
	outfname := flag.String("o", "a.crl", "Specifies output `file`. Default is a.crl")
	flag.Parse()
	infname := flag.Arg(0)
	lexer := newLexer(infname)
	cmp = newCompiler()
	parserParse(lexer)
	prep = false
	lexer = newLexer(infname)
	cmp.reset()
	parserParse(lexer)
	outf, _ := os.Create(*outfname)
	defer outf.Close()
	outwriter := bufio.NewWriter(outf)
	outwriter.WriteString(cmp.export())
	outwriter.Flush()
}

//line yacctab:1
var parserExca = [...]int8{
	-1, 1,
	1, -1,
	-2, 0,
	-1, 60,
	40, 67,
	-2, 26,
}

const parserPrivate = 57344

const parserLast = 232

var parserAct = [...]uint8{
	120, 51, 42, 163, 92, 125, 186, 123, 75, 121,
	126, 99, 54, 78, 122, 33, 17, 116, 208, 103,
	124, 219, 218, 209, 213, 204, 200, 211, 31, 119,
	7, 60, 22, 86, 87, 34, 18, 141, 6, 56,
	3, 64, 185, 57, 21, 12, 67, 137, 13, 58,
	10, 59, 182, 50, 187, 226, 127, 100, 23, 63,
	62, 39, 36, 139, 88, 84, 76, 144, 145, 147,
	146, 148, 149, 68, 69, 70, 85, 60, 141, 28,
	20, 101, 98, 102, 96, 97, 141, 104, 159, 71,
	105, 16, 37, 65, 30, 217, 142, 165, 95, 94,
	93, 91, 90, 89, 141, 113, 114, 128, 129, 130,
	131, 132, 133, 134, 117, 29, 150, 151, 153, 143,
	86, 87, 135, 136, 214, 152, 79, 4, 158, 138,
	154, 155, 156, 8, 164, 157, 72, 73, 74, 140,
	160, 83, 82, 77, 41, 161, 40, 25, 24, 9,
	162, 166, 168, 169, 170, 171, 172, 173, 167, 115,
	178, 179, 180, 181, 225, 183, 184, 220, 202, 196,
	188, 174, 175, 176, 177, 81, 222, 210, 201, 194,
	215, 206, 197, 189, 112, 111, 110, 109, 108, 190,
	193, 191, 107, 192, 106, 198, 53, 199, 195, 52,
	49, 48, 47, 203, 46, 205, 207, 45, 44, 43,
	61, 118, 212, 80, 66, 216, 35, 27, 15, 221,
	11, 223, 32, 224, 38, 26, 19, 14, 5, 2,
	1, 55,
}

var parserPact = [...]int16{
	11, -1000, 9, 0, -1000, 9, 144, 23, -1000, -1000,
	17, 21, -1000, -15, 56, 16, 32, 143, 142, -1000,
	-1000, 55, -1000, -15, 72, -1000, -16, -1000, -1000, 32,
	69, -1000, -16, 141, 139, 7, -1000, -1000, 7, -1000,
	71, -1000, -1000, 7, -1000, -1000, -1000, -1000, -1000, -1000,
	-1000, -1000, -1000, -1000, 67, 130, -1000, -1000, 138, -1000,
	-1000, -1000, 137, 136, 40, 116, 39, -1000, 84, 83,
	82, -1000, 81, 80, 79, -1000, -1000, -1000, 31, 53,
	7, -21, -1000, -1000, -1000, 64, -1000, 68, -1000, -1000,
	-1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -28,
	-1000, -1000, -1000, -2, -1000, 29, 29, 29, 29, 29,
	29, 29, 29, -1000, -1000, 20, -1000, 31, 38, 134,
	73, 107, 51, 110, 121, -1000, -1000, 29, 91, 91,
	91, 65, 91, 91, 91, -1000, -1000, 129, -1000, -1000,
	78, 29, -1000, 29, 29, 29, 29, 29, 29, 29,
	29, 29, 29, 29, 29, 29, 29, 29, 24, -1000,
	-1000, -1000, 14, 28, -1000, -1000, 107, 51, 110, 110,
	110, 110, 110, 110, 121, 121, 121, 121, -1000, -1000,
	-1000, -1000, -1000, -1000, -1000, -1000, -1000, 129, -1000, 29,
	-1000, 28, -1000, 91, 29, -1000, 29, -7, 91, 91,
	7, -12, 7, -1000, 53, -23, -11, -1000, -4, 7,
	-14, 119, -1000, 53, 76, -13, -18, -1000, 29, -1000,
	29, 91, 29, 91, 91, 30, -1000,
}

var parserPgo = [...]uint8{
	0, 10, 0, 9, 14, 7, 20, 5, 8, 4,
	231, 230, 229, 127, 228, 227, 226, 225, 28, 224,
	2, 222, 220, 218, 217, 216, 214, 91, 32, 1,
	213, 211, 210, 209, 208, 207, 204, 202, 201, 200,
	199, 196, 194, 192, 188, 187, 186, 185, 184, 183,
	182, 181, 180, 179, 178, 177, 176, 175, 169, 168,
	167, 164, 159, 150, 13, 11, 126, 3, 6,
}

var parserR1 = [...]int8{
	0, 11, 13, 13, 15, 12, 17, 19, 16, 18,
	18, 21, 21, 21, 22, 14, 25, 26, 24, 23,
	23, 28, 28, 27, 27, 27, 30, 31, 29, 29,
	20, 20, 33, 33, 33, 33, 33, 33, 33, 33,
	33, 33, 42, 34, 43, 34, 44, 34, 45, 10,
	46, 35, 47, 35, 48, 35, 49, 50, 51, 52,
	36, 8, 53, 54, 55, 56, 37, 57, 58, 59,
	60, 61, 32, 62, 38, 39, 65, 65, 66, 64,
	63, 63, 68, 68, 67, 40, 41, 9, 2, 2,
	3, 3, 4, 4, 4, 4, 4, 4, 4, 5,
	5, 5, 5, 5, 6, 6, 6, 6, 6, 7,
	7, 1, 1, 1,
}

var parserR2 = [...]int8{
	0, 2, 2, 0, 0, 6, 0, 0, 6, 2,
	0, 2, 2, 5, 0, 7, 0, 0, 5, 2,
	0, 3, 0, 2, 4, 2, 0, 0, 5, 1,
	2, 0, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 0, 5, 0, 5, 0, 5, 0, 6,
	0, 5, 0, 5, 0, 5, 0, 0, 0, 0,
	18, 0, 0, 0, 0, 0, 19, 0, 0, 0,
	0, 0, 20, 0, 7, 4, 3, 0, 0, 2,
	2, 0, 3, 0, 1, 2, 2, 0, 1, 3,
	1, 3, 1, 3, 3, 3, 3, 3, 3, 1,
	3, 3, 3, 3, 1, 3, 3, 3, 3, 1,
	3, 1, 1, 4,
}

var parserChk = [...]int16{
	-1000, -11, -12, 29, -13, -14, 29, 30, -13, 5,
	27, -22, 28, 27, -15, -23, -27, 31, 51, -16,
	24, 28, -28, 26, 5, 5, -17, -24, 24, -27,
	22, -18, -21, 31, 51, -25, -28, 23, -19, -18,
	5, 5, -20, -33, -34, -35, -36, -37, -38, -39,
	46, -29, -40, -41, 5, -10, 32, 36, 42, 44,
	24, -32, 53, 52, -20, 22, -26, -20, 6, 7,
	8, 22, 6, 7, 8, -8, -8, 5, -64, -66,
	-30, -57, 5, 5, 25, -1, 4, 5, 25, 19,
	19, 19, -9, 19, 19, 19, -8, -8, -9, -65,
	26, -29, -20, 40, 23, 22, -42, -43, -44, -45,
	-46, -47, -48, -8, -8, -62, 45, -64, -31, 31,
	-2, -3, -4, -5, -6, -7, -1, 27, -2, -2,
	-2, -2, -2, -2, -2, -8, -8, 27, -65, 25,
	5, 13, 23, 12, 16, 17, 19, 18, 20, 21,
	6, 7, 15, 8, 9, 10, 11, 14, -2, 23,
	-9, -8, -63, -67, 5, 19, -3, -4, -5, -5,
	-5, -5, -5, -5, -6, -6, -6, -6, -7, -7,
	-7, -7, 28, -9, -9, 28, -68, 26, -9, -49,
	-9, -67, -9, -2, -53, -68, -58, -50, -2, -2,
	33, -54, -59, -20, 37, -20, -51, -29, 41, 34,
	-55, 31, -20, 38, 5, -52, -29, 19, 35, 39,
	-60, -2, -56, -2, -2, -61, 25,
}

var parserDef = [...]int8{
	0, -2, 3, 0, 1, 3, 0, 0, 2, 14,
	0, 0, 4, 20, 0, 0, 22, 0, 0, 5,
	6, 0, 19, 0, 23, 25, 10, 15, 16, 22,
	0, 7, 10, 0, 0, 31, 21, 24, 31, 9,
	11, 12, 17, 31, 32, 33, 34, 35, 36, 37,
	38, 39, 40, 41, 0, 0, 61, 61, 0, 78,
	-2, 29, 0, 0, 0, 0, 0, 30, 0, 0,
	0, 87, 0, 0, 0, 61, 61, 87, 77, 0,
	31, 0, 85, 86, 8, 0, 111, 112, 18, 42,
	44, 46, 48, 50, 52, 54, 61, 61, 73, 0,
	78, 79, 27, 0, 13, 0, 0, 0, 0, 0,
	0, 0, 0, 61, 61, 0, 75, 77, 0, 0,
	0, 88, 90, 92, 99, 104, 109, 0, 43, 45,
	47, 0, 51, 53, 55, 87, 61, 81, 76, 28,
	0, 0, 113, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 49,
	87, 87, 0, 83, 84, 87, 89, 91, 93, 94,
	95, 96, 97, 98, 100, 101, 102, 103, 105, 106,
	107, 108, 110, 56, 87, 74, 80, 0, 87, 0,
	62, 83, 68, 57, 0, 82, 0, 0, 63, 69,
	31, 0, 31, 58, 0, 0, 0, 64, 0, 31,
	0, 0, 59, 0, 0, 0, 0, 70, 0, 65,
	0, 60, 0, 71, 66, 0, 72,
}

var parserTok1 = [...]int8{
	1,
}

var parserTok2 = [...]int8{
	2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
	12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
	22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
	32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
	42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
	52, 53,
}

var parserTok3 = [...]int8{
	0,
}

var parserErrorMessages = [...]struct {
	state int
	token int
	msg   string
}{}

//line yaccpar:1

/*	parser for yacc output	*/

var (
	parserDebug        = 0
	parserErrorVerbose = false
)

type parserLexer interface {
	Lex(lval *parserSymType) int
	Error(s string)
}

type parserParser interface {
	Parse(parserLexer) int
	Lookahead() int
}

type parserParserImpl struct {
	lval  parserSymType
	stack [parserInitialStackSize]parserSymType
	char  int
}

func (p *parserParserImpl) Lookahead() int {
	return p.char
}

func parserNewParser() parserParser {
	return &parserParserImpl{}
}

const parserFlag = -1000

func parserTokname(c int) string {
	if c >= 1 && c-1 < len(parserToknames) {
		if parserToknames[c-1] != "" {
			return parserToknames[c-1]
		}
	}
	return __yyfmt__.Sprintf("tok-%v", c)
}

func parserStatname(s int) string {
	if s >= 0 && s < len(parserStatenames) {
		if parserStatenames[s] != "" {
			return parserStatenames[s]
		}
	}
	return __yyfmt__.Sprintf("state-%v", s)
}

func parserErrorMessage(state, lookAhead int) string {
	const TOKSTART = 4

	if !parserErrorVerbose {
		return "syntax error"
	}

	for _, e := range parserErrorMessages {
		if e.state == state && e.token == lookAhead {
			return "syntax error: " + e.msg
		}
	}

	res := "syntax error: unexpected " + parserTokname(lookAhead)

	// To match Bison, suggest at most four expected tokens.
	expected := make([]int, 0, 4)

	// Look for shiftable tokens.
	base := int(parserPact[state])
	for tok := TOKSTART; tok-1 < len(parserToknames); tok++ {
		if n := base + tok; n >= 0 && n < parserLast && int(parserChk[int(parserAct[n])]) == tok {
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}
	}

	if parserDef[state] == -2 {
		i := 0
		for parserExca[i] != -1 || int(parserExca[i+1]) != state {
			i += 2
		}

		// Look for tokens that we accept or reduce.
		for i += 2; parserExca[i] >= 0; i += 2 {
			tok := int(parserExca[i])
			if tok < TOKSTART || parserExca[i+1] == 0 {
				continue
			}
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}

		// If the default action is to accept or reduce, give up.
		if parserExca[i+1] != 0 {
			return res
		}
	}

	for i, tok := range expected {
		if i == 0 {
			res += ", expecting "
		} else {
			res += " or "
		}
		res += parserTokname(tok)
	}
	return res
}

func parserlex1(lex parserLexer, lval *parserSymType) (char, token int) {
	token = 0
	char = lex.Lex(lval)
	if char <= 0 {
		token = int(parserTok1[0])
		goto out
	}
	if char < len(parserTok1) {
		token = int(parserTok1[char])
		goto out
	}
	if char >= parserPrivate {
		if char < parserPrivate+len(parserTok2) {
			token = int(parserTok2[char-parserPrivate])
			goto out
		}
	}
	for i := 0; i < len(parserTok3); i += 2 {
		token = int(parserTok3[i+0])
		if token == char {
			token = int(parserTok3[i+1])
			goto out
		}
	}

out:
	if token == 0 {
		token = int(parserTok2[1]) /* unknown char */
	}
	if parserDebug >= 3 {
		__yyfmt__.Printf("lex %s(%d)\n", parserTokname(token), uint(char))
	}
	return char, token
}

func parserParse(parserlex parserLexer) int {
	return parserNewParser().Parse(parserlex)
}

func (parserrcvr *parserParserImpl) Parse(parserlex parserLexer) int {
	var parsern int
	var parserVAL parserSymType
	var parserDollar []parserSymType
	_ = parserDollar // silence set and not used
	parserS := parserrcvr.stack[:]

	Nerrs := 0   /* number of errors */
	Errflag := 0 /* error recovery flag */
	parserstate := 0
	parserrcvr.char = -1
	parsertoken := -1 // parserrcvr.char translated into internal numbering
	defer func() {
		// Make sure we report no lookahead when not parsing.
		parserstate = -1
		parserrcvr.char = -1
		parsertoken = -1
	}()
	parserp := -1
	goto parserstack

ret0:
	return 0

ret1:
	return 1

parserstack:
	/* put a state and value onto the stack */
	if parserDebug >= 4 {
		__yyfmt__.Printf("char %v in %v\n", parserTokname(parsertoken), parserStatname(parserstate))
	}

	parserp++
	if parserp >= len(parserS) {
		nyys := make([]parserSymType, len(parserS)*2)
		copy(nyys, parserS)
		parserS = nyys
	}
	parserS[parserp] = parserVAL
	parserS[parserp].yys = parserstate

parsernewstate:
	parsern = int(parserPact[parserstate])
	if parsern <= parserFlag {
		goto parserdefault /* simple state */
	}
	if parserrcvr.char < 0 {
		parserrcvr.char, parsertoken = parserlex1(parserlex, &parserrcvr.lval)
	}
	parsern += parsertoken
	if parsern < 0 || parsern >= parserLast {
		goto parserdefault
	}
	parsern = int(parserAct[parsern])
	if int(parserChk[parsern]) == parsertoken { /* valid shift */
		parserrcvr.char = -1
		parsertoken = -1
		parserVAL = parserrcvr.lval
		parserstate = parsern
		if Errflag > 0 {
			Errflag--
		}
		goto parserstack
	}

parserdefault:
	/* default state action */
	parsern = int(parserDef[parserstate])
	if parsern == -2 {
		if parserrcvr.char < 0 {
			parserrcvr.char, parsertoken = parserlex1(parserlex, &parserrcvr.lval)
		}

		/* look through exception table */
		xi := 0
		for {
			if parserExca[xi+0] == -1 && int(parserExca[xi+1]) == parserstate {
				break
			}
			xi += 2
		}
		for xi += 2; ; xi += 2 {
			parsern = int(parserExca[xi+0])
			if parsern < 0 || parsern == parsertoken {
				break
			}
		}
		parsern = int(parserExca[xi+1])
		if parsern < 0 {
			goto ret0
		}
	}
	if parsern == 0 {
		/* error ... attempt to resume parsing */
		switch Errflag {
		case 0: /* brand new error */
			parserlex.Error(parserErrorMessage(parserstate, parsertoken))
			Nerrs++
			if parserDebug >= 1 {
				__yyfmt__.Printf("%s", parserStatname(parserstate))
				__yyfmt__.Printf(" saw %s\n", parserTokname(parsertoken))
			}
			fallthrough

		case 1, 2: /* incompletely recovered error ... try again */
			Errflag = 3

			/* find a state where "error" is a legal shift action */
			for parserp >= 0 {
				parsern = int(parserPact[parserS[parserp].yys]) + parserErrCode
				if parsern >= 0 && parsern < parserLast {
					parserstate = int(parserAct[parsern]) /* simulate a shift of "error" */
					if int(parserChk[parserstate]) == parserErrCode {
						goto parserstack
					}
				}

				/* the current p has no shift on "error", pop stack */
				if parserDebug >= 2 {
					__yyfmt__.Printf("error recovery pops state %d\n", parserS[parserp].yys)
				}
				parserp--
			}
			/* there is no state on the stack with an error shift ... abort */
			goto ret1

		case 3: /* no shift yet; clobber input char */
			if parserDebug >= 2 {
				__yyfmt__.Printf("error recovery discards %s\n", parserTokname(parsertoken))
			}
			if parsertoken == parserEofCode {
				goto ret1
			}
			parserrcvr.char = -1
			parsertoken = -1
			goto parsernewstate /* try again in the same state */
		}
	}

	/* reduction by production parsern */
	if parserDebug >= 2 {
		__yyfmt__.Printf("reduce %v in:\n\t%v\n", parsern, parserStatname(parserstate))
	}

	parsernt := parsern
	parserpt := parserp
	_ = parserpt // guard against "declared and not used"

	parserp -= int(parserR2[parsern])
	// parserp is now the index of $0. Perform the default action. Iff the
	// reduced production is Îµ, $1 is possibly out of range.
	if parserp+1 >= len(parserS) {
		nyys := make([]parserSymType, len(parserS)*2)
		copy(nyys, parserS)
		parserS = nyys
	}
	parserVAL = parserS[parserp+1]

	/* consult goto table to find next state */
	parsern = int(parserR1[parsern])
	parserg := int(parserPgo[parsern])
	parserj := parserg + parserS[parserp].yys + 1

	if parserj >= parserLast {
		parserstate = int(parserAct[parserg])
	} else {
		parserstate = int(parserAct[parserj])
		if int(parserChk[parserstate]) != -parsern {
			parserstate = int(parserAct[parserg])
		}
	}
	// dummy call; replaced with literal code
	switch parsernt {

	case 4:
		parserDollar = parserS[parserpt-4 : parserpt+1]
//line parser.y:38
		{
			if prep {
				cmp.addProc("main")
			} else {
				cmp.beginProc("main")
				cmp.exec("begin main")
			}
		}
	case 5:
		parserDollar = parserS[parserpt-6 : parserpt+1]
//line parser.y:47
		{
			if !prep {
				cmp.exec("end main")
			}
			cmp.endProc()
		}
	case 6:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:55
		{
			if !prep {
				cmp.exec("indent " + cmp.getNextMod())
			}
			cmp.indent()
		}
	case 7:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:61
		{
			if !prep {
				for k, v := range cmp.memrec {
					t := cmp.glovartype[k]
					cmp.exec("set #" + k + " " + t + " M[" + strconv.Itoa(v) + "]")
				}
			}
		}
	case 8:
		parserDollar = parserS[parserpt-6 : parserpt+1]
//line parser.y:70
		{
			if !prep {
				for k, v := range cmp.memrec {
					t := cmp.glovartype[k]
					cmp.exec("unset #" + k + " " + t + " M[" + strconv.Itoa(v) + "]")
				}
			}
			if !prep {
				cmp.exec("unindent " + cmp.getCurrentMod())
			}
			cmp.unindent()
		}
	case 11:
		parserDollar = parserS[parserpt-2 : parserpt+1]
//line parser.y:86
		{
			if !prep {
				cmp.newmem(parserDollar[2].ident, 1, "int")

			}
		}
	case 12:
		parserDollar = parserS[parserpt-2 : parserpt+1]
//line parser.y:92
		{
			if !prep {
				cmp.newmem(parserDollar[2].ident, 1, "sync")
			}
		}
	case 13:
		parserDollar = parserS[parserpt-5 : parserpt+1]
//line parser.y:98
		{
			if !prep {
				size, _ := strconv.Atoi(parserDollar[4].varid)
				cmp.newmem(parserDollar[2].ident, size, "int[]")
			}
		}
	case 14:
		parserDollar = parserS[parserpt-2 : parserpt+1]
//line parser.y:106
		{
			if prep {
				cmp.addProc(parserDollar[2].ident)
			} else {
				cmp.beginProc(parserDollar[2].ident)
				cmp.exec("begin " + parserDollar[2].ident)
			}
		}
	case 15:
		parserDollar = parserS[parserpt-7 : parserpt+1]
//line parser.y:115
		{
			if !prep {
				cmp.exec("end " + parserDollar[2].ident)
			}
			cmp.endProc()
		}
	case 16:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:123
		{
			if !prep {
				cmp.exec("indent " + cmp.getNextMod())
			}
			cmp.indent()
		}
	case 17:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:130
		{
			if !prep {
				cmp.exec("unindent " + cmp.getCurrentMod())
			}
			cmp.unindent()
		}
	case 23:
		parserDollar = parserS[parserpt-2 : parserpt+1]
//line parser.y:146
		{
			if prep {
				cmp.addProcArg(parserDollar[2].ident, "int")
			}
		}
	case 24:
		parserDollar = parserS[parserpt-4 : parserpt+1]
//line parser.y:152
		{
			if prep {
				cmp.addProcArg(parserDollar[2].ident, "int[]")
			}
		}
	case 25:
		parserDollar = parserS[parserpt-2 : parserpt+1]
//line parser.y:158
		{
			if prep {
				cmp.addProcArg(parserDollar[2].ident, "sync")
			}
		}
	case 26:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:165
		{
			if !prep {
				cmp.exec("indent " + cmp.getNextMod())
			}
			cmp.indent()
		}
	case 27:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:172
		{
			if !prep {
				cmp.exec("unindent " + cmp.getCurrentMod())
			}
			cmp.unindent()
		}
	case 42:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:196
		{
			if !prep {
				cmp.recordToken()
			}
		}
	case 43:
		parserDollar = parserS[parserpt-5 : parserpt+1]
//line parser.y:202
		{
			if !prep {
				cmp.exec(parserDollar[1].ident + " += " + cmp.getRecordedToken())
			}

		}
	case 44:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:209
		{
			if !prep {
				cmp.recordToken()
			}
		}
	case 45:
		parserDollar = parserS[parserpt-5 : parserpt+1]
//line parser.y:215
		{
			if !prep {
				cmp.exec(parserDollar[1].ident + " -= " + cmp.getRecordedToken())
			}

		}
	case 46:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:222
		{
			if !prep {
				cmp.recordToken()
			}
		}
	case 47:
		parserDollar = parserS[parserpt-5 : parserpt+1]
//line parser.y:228
		{
			if !prep {
				cmp.exec(parserDollar[1].ident + " ^= " + cmp.getRecordedToken())
			}

		}
	case 48:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:235
		{
			if !prep {
				cmp.beginRecord(parserDollar[3].varid)
			}
		}
	case 49:
		parserDollar = parserS[parserpt-6 : parserpt+1]
//line parser.y:241
		{
			if !prep {
				cmp.endRecord(parserDollar[3].varid)
				parserVAL.varid = parserDollar[1].ident + "[" + parserDollar[5].varid + "]"
			}
		}
	case 50:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:248
		{
			if !prep {
				cmp.recordToken()
			}
		}
	case 51:
		parserDollar = parserS[parserpt-5 : parserpt+1]
//line parser.y:254
		{
			if !prep {
				cmp.exec(parserDollar[1].varid + " += " + cmp.getRecordedToken())
			}

		}
	case 52:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:261
		{
			if !prep {
				cmp.recordToken()
			}
		}
	case 53:
		parserDollar = parserS[parserpt-5 : parserpt+1]
//line parser.y:267
		{
			if !prep {
				cmp.exec(parserDollar[1].varid + " -= " + cmp.getRecordedToken())
			}

		}
	case 54:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:274
		{
			if !prep {
				cmp.recordToken()
			}
		}
	case 55:
		parserDollar = parserS[parserpt-5 : parserpt+1]
//line parser.y:280
		{
			if !prep {
				cmp.exec(parserDollar[1].varid + " ^= " + cmp.getRecordedToken())
			}

		}
	case 56:
		parserDollar = parserS[parserpt-7 : parserpt+1]
//line parser.y:288
		{
			if !prep {
				cmp.beginRecord(parserDollar[6].varid)
			}
		}
	case 57:
		parserDollar = parserS[parserpt-9 : parserpt+1]
//line parser.y:294
		{
			if !prep {
				cmp.endRecord(parserDollar[6].varid)
				cmp.execEarlyRecord(parserDollar[6].varid)
				cmp.exec(parserDollar[9].varid + " -> " + parserDollar[2].varid + ";" + parserDollar[3].varid)
				cmp.exec(parserDollar[2].varid + " <-")
				cmp.execLateRecord(parserDollar[6].varid)
			}
		}
	case 58:
		parserDollar = parserS[parserpt-12 : parserpt+1]
//line parser.y:304
		{
			if !prep {
				cmp.execEarlyRecord(parserDollar[7].varid)
				cmp.exec("-> " + parserDollar[4].varid)
				cmp.exec(parserDollar[3].varid + " <-")
				cmp.execLateRecord(parserDollar[6].varid)
			}
		}
	case 59:
		parserDollar = parserS[parserpt-15 : parserpt+1]
//line parser.y:313
		{
			if !prep {
				cmp.execEarlyRecord(parserDollar[7].varid)
				cmp.exec("-> " + parserDollar[5].varid)
				cmp.beginRecord(parserDollar[7].varid)
			}
		}
	case 60:
		parserDollar = parserS[parserpt-18 : parserpt+1]
//line parser.y:321
		{
			if !prep {
				cmp.endRecord(parserDollar[7].varid)
				cmp.exec(parserDollar[4].varid + ";" + parserDollar[5].varid + " <- " + parserDollar[18].varid)
				cmp.execLateRecord(parserDollar[7].varid)
			}
		}
	case 61:
		parserDollar = parserS[parserpt-0 : parserpt+1]
//line parser.y:330
		{
			if !prep {
				parserVAL.varid = cmp.getLabel()
			}
		}
	case 62:
		parserDollar = parserS[parserpt-8 : parserpt+1]
//line parser.y:337
		{
			if !prep {
				cmp.beginRecord(parserDollar[7].varid)
			}
		}
	case 63:
		parserDollar = parserS[parserpt-10 : parserpt+1]
//line parser.y:343
		{
			if !prep {
				cmp.endRecord(parserDollar[7].varid)
				cmp.execEarlyRecord(parserDollar[7].varid)
				cmp.exec("-> " + parserDollar[2].varid)
				cmp.exec(parserDollar[2].varid + ";" + parserDollar[6].varid + " <- " + parserDollar[10].varid)
				cmp.execLateRecord(parserDollar[7].varid)
			}
		}
	case 64:
		parserDollar = parserS[parserpt-13 : parserpt+1]
//line parser.y:353
		{
			if !prep {
				cmp.exec("-> " + parserDollar[3].varid)
				cmp.exec(parserDollar[5].varid + " <-")
				cmp.execLateRecord(parserDollar[8].varid)
			}
		}
	case 65:
		parserDollar = parserS[parserpt-17 : parserpt+1]
//line parser.y:361
		{
			if !prep {
				cmp.execEarlyRecord(parserDollar[7].varid)
				cmp.exec("-> " + parserDollar[6].varid)
				cmp.exec(parserDollar[3].varid + " <-")
				cmp.beginRecord(parserDollar[8].varid)
			}
		}
	case 66:
		parserDollar = parserS[parserpt-19 : parserpt+1]
//line parser.y:370
		{
			if !prep {
				cmp.endRecord(parserDollar[8].varid)
				cmp.execEarlyRecord(parserDollar[8].varid)
				cmp.exec(parserDollar[19].varid + " -> " + parserDollar[4].varid + ";" + parserDollar[5].varid)
				cmp.exec(parserDollar[4].varid + " <-")
				cmp.execLateRecord(parserDollar[8].varid)
			}
		}
	case 67:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:381
		{
			if !prep {
				cmp.exec("indent " + cmp.getNextMod())
			}
			cmp.indent()
		}
	case 68:
		parserDollar = parserS[parserpt-8 : parserpt+1]
//line parser.y:388
		{
			if !prep {
				cmp.beginRecord(parserDollar[7].varid)
			}
		}
	case 69:
		parserDollar = parserS[parserpt-10 : parserpt+1]
//line parser.y:394
		{
			if !prep {
				cmp.endRecord(parserDollar[7].varid)
				cmp.execEarlyRecord(parserDollar[7].varid)
				cmp.exec("$" + parserDollar[5].ident + " += " + parserDollar[10].varid)
				cmp.execLateRecord(parserDollar[7].varid)
			}
		}
	case 70:
		parserDollar = parserS[parserpt-16 : parserpt+1]
//line parser.y:403
		{
			if !prep {
				cmp.beginRecord(parserDollar[8].varid)
			}
		}
	case 71:
		parserDollar = parserS[parserpt-18 : parserpt+1]
//line parser.y:409
		{
			if !prep {
				cmp.endRecord(parserDollar[8].varid)
				cmp.execEarlyRecord(parserDollar[8].varid)
				cmp.exec("$" + parserDollar[15].ident + " -= " + parserDollar[18].varid)
				cmp.execLateRecord(parserDollar[8].varid)
				cmp.exec("unindent " + cmp.getCurrentMod())
			}
			cmp.unindent()
		}
	case 73:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:422
		{
			if !prep {
				cmp.setCallingProc(parserDollar[2].ident)
				cmp.beginRecord(parserDollar[3].varid)
				cmp.argindex = 0
			}
		}
	case 74:
		parserDollar = parserS[parserpt-7 : parserpt+1]
//line parser.y:430
		{
			if !prep {
				cmp.endRecord(parserDollar[3].varid)
				cmp.argindex = 0
				cmp.execEarlyRecord(parserDollar[3].varid)
				cmp.exec("call " + parserDollar[2].ident)
				cmp.execLateRecord(parserDollar[3].varid)
			}
		}
	case 75:
		parserDollar = parserS[parserpt-4 : parserpt+1]
//line parser.y:441
		{
			if !prep {
				s := ""
				for i := range cmp.getParCount() + 1 {
					if i != 0 {
						s += ","
					}
					s += " "
					s += "$" + cmp.getBlockId() + "." + strconv.Itoa(i)
				}
				cmp.exec("call" + s)
			}
		}
	case 78:
		parserDollar = parserS[parserpt-0 : parserpt+1]
//line parser.y:459
		{
			if prep {
				cmp.addProc("$" + cmp.getBlockId() + "." + cmp.getNextMod())
			}
			if !prep {
				cmp.beginProc("$" + cmp.getBlockId() + "." + cmp.getNextMod())
				cmp.exec("begin $" + cmp.getBlockId() + "." + cmp.getNextMod())
			}
		}
	case 79:
		parserDollar = parserS[parserpt-2 : parserpt+1]
//line parser.y:469
		{
			if !prep {
				cmp.exec("end $" + cmp.getBlockId() + "." + cmp.getPrevNextMod())
			}
			cmp.endProc()
		}
	case 84:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:484
		{
			if !prep {
				i, t := cmp.getProcArg()
				cmp.exec("set $" + i + ":" + cmp.getCallingProcId() + " " + t + " " + parserDollar[1].ident)
				cmp.unexec("unset $" + i + ":" + cmp.getCallingProcId() + " " + t + " " + parserDollar[1].ident)
			}
		}
	case 85:
		parserDollar = parserS[parserpt-2 : parserpt+1]
//line parser.y:493
		{
			if !prep {
				cmp.exec("V " + parserDollar[2].ident)
			}
		}
	case 86:
		parserDollar = parserS[parserpt-2 : parserpt+1]
//line parser.y:499
		{
			if !prep {
				cmp.exec("P " + parserDollar[2].ident)
			}
		}
	case 87:
		parserDollar = parserS[parserpt-0 : parserpt+1]
//line parser.y:506
		{
			parserVAL.varid = cmp.getRec()
		}
	case 88:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:511
		{
			parserVAL.varid = parserDollar[1].varid
		}
	case 89:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:515
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec(tmp + " += " + parserDollar[1].varid + " ||" + parserDollar[3].varid)
				cmp.exec(tmp + " -= " + parserDollar[1].varid + " ||" + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 90:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:524
		{
			parserVAL.varid = parserDollar[1].varid
		}
	case 91:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:528
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec(tmp + " += " + parserDollar[1].varid + " && " + parserDollar[3].varid)
				cmp.unexec(tmp + " -= " + parserDollar[1].varid + " && " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 92:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:538
		{
			parserVAL.varid = parserDollar[1].varid
		}
	case 93:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:542
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec(tmp + " += " + parserDollar[1].varid + " <= " + parserDollar[3].varid)
				cmp.unexec(tmp + " -= " + parserDollar[1].varid + " <= " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 94:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:551
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec(tmp + " += " + parserDollar[1].varid + " >= " + parserDollar[3].varid)
				cmp.unexec(tmp + " -= " + parserDollar[1].varid + " >= " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 95:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:560
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec(tmp + " += " + parserDollar[1].varid + " == " + parserDollar[3].varid)
				cmp.unexec(tmp + " -= " + parserDollar[1].varid + " == " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 96:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:569
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec(tmp + " += " + parserDollar[1].varid + " != " + parserDollar[3].varid)
				cmp.unexec(tmp + " -= " + parserDollar[1].varid + " != " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 97:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:578
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec(tmp + " += " + parserDollar[1].varid + " < " + parserDollar[3].varid)
				cmp.unexec(tmp + " -= " + parserDollar[1].varid + " < " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 98:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:587
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec(tmp + " += " + parserDollar[1].varid + " > " + parserDollar[3].varid)
				cmp.unexec(tmp + " -= " + parserDollar[1].varid + " > " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 99:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:596
		{
			parserVAL.varid = parserDollar[1].varid
		}
	case 100:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:600
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec(tmp + " += " + parserDollar[1].varid + " + " + parserDollar[3].varid)
				cmp.unexec(tmp + " -= " + parserDollar[1].varid + " + " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 101:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:609
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec(tmp + " += " + parserDollar[1].varid + " - " + parserDollar[3].varid)
				cmp.unexec(tmp + " -= " + parserDollar[1].varid + " - " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 103:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:619
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec(tmp + " += " + parserDollar[1].varid + " ^ " + parserDollar[3].varid)
				cmp.unexec(tmp + " -= " + parserDollar[1].varid + " ^ " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 104:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:628
		{
			parserVAL.varid = parserDollar[1].varid
		}
	case 105:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:632
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec(tmp + " += " + parserDollar[1].varid + " * " + parserDollar[3].varid)
				cmp.unexec(tmp + " -= " + parserDollar[1].varid + " * " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 106:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:641
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec(tmp + " += " + parserDollar[1].varid + " / " + parserDollar[3].varid)
				cmp.unexec(tmp + " -= " + parserDollar[1].varid + " / " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 107:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:650
		{
			if !prep {
				tmp := cmp.getTmp()
				cmp.exec(tmp + " += " + parserDollar[1].varid + " % " + parserDollar[3].varid)
				cmp.unexec(tmp + " -= " + parserDollar[1].varid + " % " + parserDollar[3].varid)
				parserVAL.varid = tmp
			}
		}
	case 109:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:661
		{
			parserVAL.varid = parserDollar[1].varid
		}
	case 110:
		parserDollar = parserS[parserpt-3 : parserpt+1]
//line parser.y:665
		{
			parserVAL.varid = parserDollar[2].varid
		}
	case 111:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:670
		{
			if !prep {
				parserVAL.varid = strconv.Itoa(parserDollar[1].num)
			}
		}
	case 112:
		parserDollar = parserS[parserpt-1 : parserpt+1]
//line parser.y:676
		{
			if !prep {
				parserVAL.varid = parserDollar[1].ident
			}
		}
	case 113:
		parserDollar = parserS[parserpt-4 : parserpt+1]
//line parser.y:682
		{
			if !prep {
				parserVAL.varid = parserDollar[1].ident + "[" + parserDollar[3].varid + "]"
			}
		}
	}
	goto parserstack /* stack new state and value */
}
